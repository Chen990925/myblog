---
group: java基础
title: java基础面试题1
order: 1
---

# Java基础 面试题

##  面向对象有哪些特性？

面向对象四大特性：封装，继承，多态，

1、封装就是将类的信息隐藏在类内部，不允许外部程序直接访问，而是通过该类的方法实现对隐藏信息的操作和访问。 **良好的封装能够减少耦合**。

2、继承是从已有的类中派生出新的类，新的类继承父类的属性和行为，并能扩展新的能力，大大增加程序的重用性和易维护性。在 Java 中是单继承的，也就是说一个子类只有一个父类。

3、多态是同一个行为具有多个不同表现形式的能力。在不修改程序代码的情况下改变程序运行时绑定的代码。实现多态的三要素：继承、重写、父类引用指向子类对象。

- 静态多态性：通过**重载**实现，相同的方法有不同的參数列表，可以根据参数的不同，做出不同的处理。
- 动态多态性：在子类中重写父类的方法。运行期间判断所引用对象的实际类型，根据其实际类型调用相应的方法。



## **Java 创建对象有几种方式**

1. 使用 **new 关键字**：这是最常见的创建对象的方式。通过调用类的构造函数，使用 new 关键字可以在内存中分配一个新的对象。
2. 使用**反射**：Java 的反射机制允许在运行时动态地创建对象。通过获取类的 Class 对象，并调用其构造函数，可以实现对象的创建。
3. 使用 newInstance () 方法：某些类提供了 newInstance () 方法来创建对象，这种方式只适用于具有默认无参构造函数的类。
4. 使用 **clone ()** 方法：如果类实现了 Cloneable 接口，就可以使用 clone () 方法创建对象的副本。
5. 使用对象的**反序列化**：通过将对象序列化到一个字节流中，然后再进行反序列化，可以创建对象的副本。



## **equals 与 == 区别**(为什么要重写equals)

"==" 比较的是变量的值或引用的地址值，而 "equals ()" 比较的是对象的内容。

> 对于引用类型，使用 "equals ()" 进行比较更加准确和灵活，但需要注意重写 "equals ()" 方法，以满足自定义的比较需求。
>
> 如果调用Object的equals方法必须是原对象本身才会返回true，所以一定要重写equals

```java
//Object的equals 
public boolean equals(Object obj) {
        return (this == obj);
    }
```



## **final，finally，finalize 的区别**

- final 是修饰符，用于限定类、方法和变量的性质。

  - 用于修饰类时，表示该类不能被继承，即为最终类。

  - 用于修饰方法时，表示该方法不能被子类重写。

  - 用于修饰变量时，表示该变量是一个常量，其值不能被修改。

- finally 是一个关键字，用于定义一个代码块，在异常处理中用于确保特定代码无论如何都会被执行。

- finalize 是一个 Object 类中的方法，用于对象的垃圾回收前的清理操作。



## **重载和重写的区别**

在 Java 中，重载和重写是两个不同的概念，它们都用于实现多态性，但是具体的实现方式和作用不同。

1. 重载：

   - 重载是指在同一个类中，可以有多个方法名相同但**参数类型、参数个数或参数顺序**不同的方法。

     > 重载的作用是增加方法的灵活性和可读性，让同一个方法名可以对不同情况进行处理。

2. 重写：

   - 重写是指在子类中可以对父类的方法进行重写。

   - 重写方法必须与被重写方法拥有相同的方法名、返回值类型和参数列表，但是可以更改访问修饰符、抛出的异常类型和方法体等。

     > 通过父类引用调用子类对象的方法，实现对同一方法名的不同实现。

   区别：

   - 重载是指在同一个类中对相同方法名的多次定义，而重写是指在继承关系中对父类方法的重新定义。
   - 重载的**方法签名**（方法名、参数类型、个数和顺序）必须**不同**，而重写的**方法签名必须相同**。
   - 重载的目的是提供**更加灵活的方法调用方式**，重写的目的是**实现多态性**。



## ***抽象类和接口有什么区别**

1. 抽象类是使用 abstract 关键字定义的类，可以包含抽象方法和非抽象方法，可以有实例变量和构造方法

   接口通过 interface 关键字定义，只能包含抽象方法、默认方法和静态方法，不包含实例变量或构造方法。

2. 一个类只能继承自一个抽象类，但可以实现多个接口

3. 抽象类可以包含**非抽象方法**，子类可以直接使用；接口可以包含**默认方法**，提供通用实现

抽象类的设计目的是提供类的继承机制，实现代码复用，适用于拥有相似行为和属性的类

接口的设计目的是定义一组规范或契约，实现类遵循特定的行为和功能，适用于不同类之间的解耦和多态性实现。



## **String，Stringbuffer，StringBuilder 的区别**

1. 可变性：
   - String 是不可变的类，一旦创建就不能被修改。每次对 String 进行操作时，都会创建一个新的 String 对象。
   - StringBuffer 和 StringBuilder 是可变的类，可以动态修改字符串内容。
2. 线程安全性：
   - String 是线程安全的，因为它是不可变的。多个线程可以同时访问同一个 String 对象而无需担心数据的修改问题。
   - StringBuffer 是线程安全的，它的方法使用了 synchronized 关键字进行同步，保证在多线程环境下的安全性。
   - StringBuilder 是非线程安全的，不使用 synchronized 关键字，所以在多线程环境下使用时需要手动进行同步控制。
3. 性能：
   - 由于 String 是不可变的，每次对 String 进行操作都会创建一个新的 String 对象，频繁的字符串拼接会导致大量的对象创建和内存消耗。
   - StringBuffer 是可变的，对字符串的修改是在原有对象上进行，不会创建新的对象，因此在频繁的字符串拼接场景下比 String 更高效。
   - StringBuilder 与 StringBuffer 类似，但不保证线程安全性，因此在单线程环境下性能更高。



## **反射用途及实现原理**

- 反射是 Java 语言中的一项特性，它允许程序在运行时**动态地获取和操作类的信息**。通过反射，我们可以在编译时未知的情况下，获取类的**构造函数、方法、字段，并在运行时动态地创建对象、调用方法以及访问和修改字段的值**。

- 反射的应用有很多方面。首先，它提供了一种**动态加载类**的机制，使得我们可以在运行时根据需要加载外部的类和资源，实现插件化的架构。

- 其次，反射能够实现**对象的动态创建和初始化**。通过获取类的构造函数，并调用 newInstance () 方法，我们可以在运行时动态地创建对象，而不需要提前知道具体的类名。

- 另外，通过反射可以**动态地调用类的方法**。我们可以获取类的方法对象，并使用 **invoke ()** 方法来调用这些方法，甚至可以调用私有方法。

- 反射还允许我们**获取类的字段信息**，并在运行时对其进行读取和修改。通过获取字段对象并使用get()和set()方法，我们可以访问和修改类的字段，包括私有字段。

- 此外，反射还提供了检查类的注解、泛型信息以及父类和接口的能力，为框架开发和工具编写提供了便利。

  尽管反射提供了很大的灵活性，但也需要注意它的使用场景和性能影响。反射操作通常比直接调用方法和访问字段的**性能要低**，因此在对性能要求较高的场景中应谨慎使用。



## **什么是守护线程？与普通线程的区别**

守护线程是在程序运行时在后台提供一种支持性的线程。与普通线程相比，守护线程有以下几个区别：

1. 终止条件：当所有用户线程结束时，守护线程会自动停止。换句话说，**守护线程不会阻止程序的终止，即使它们还没有执行完任务**。
2. 生命周期：守护线程的生命周期与主线程或其他用户线程无关。**当所有的非守护线程都结束时，JVM 将会退出并停止守护线程的执行**。
3. 线程优先级：守护线程的优先级默认与普通线程一样。优先级较高的守护线程也不能够保证在其他线程之前执行。
4. 资源回收：守护线程通常被用于执行一些后台任务，例如**垃圾回收、日志记录、定时任务**等。当只剩下守护线程时，JVM 会自动退出并且不会等待守护线程执行完毕。

​	需要注意的是，守护线程与普通线程在编写代码时没有太大的区别。可以通过将线程的setDaemon(true)方法设置为 true，将普通线程转换为守护线程。
​	总结起来，守护线程在程序运行过程中提供了一种支持性的服务，会在所有的用户线程结束时自动停止。



## 深拷贝和浅拷贝

**浅拷贝**：拷⻉对象和原始对象的引⽤类型引用同⼀个对象

**深拷贝**：拷贝对象和原始对象的引用类型引用不同的对象

- 序列化和反序列化：通过将对象序列化为字节流，然后再从字节流中反序列化出一个新的对象来实现深拷贝。
- 通过手动实现 `clone` 方法：实现 `Cloneable` 接口，并重写 `clone` 方法。在 `clone` 方法中，对所有可变对象进行深拷贝
- 使用第三方库



## 类实例化的顺序

Java 中类实例化顺序：

1. 静态属性，静态代码块。
2. 普通属性，普通代码块。
3. 构造方法。



## 什么时候需要用到序列化和反序列化

当我们只在本地 JVM 里运行下 Java 实例，这个时候是不需要什么序列化和反序列化的，但当我们需要将内存中的对象持久化到磁盘，数据库中时，当我们需要与浏览器进行交互时，当我们需要实现 RPC 时，这个时候就需要序列化和反序列化了.

前两个需要用到序列化和反序列化的场景，是不是让我们有一个很大的疑问？我们在与浏览器交互时，还有将内存中的对象持久化到数据库中时，好像都没有去进行序列化和反序列化，因为我们都没有实现 Serializable 接口，但一直正常运行

下面先给出结论:

**只要我们对内存中的对象进行持久化或网络传输，这个时候都需要序列化和反序列化.**

理由:

服务器与浏览器交互时真的没有用到 Serializable 接口吗？JSON 格式实际上就是将一个对象转化为字符串，所以服务器与浏览器交互时的数据格式其实是字符串，我们来看来 String 类型的源码

String 类型实现了 Serializable 接口，并显示指定 serialVersionUID 的值.

然后我们再来看对象持久化到数据库中时的情况，Mybatis 数据库映射文件里的 insert 代码:



```text
<insert id="insertUser" parameterType="org.tyshawn.bean.User">
    INSERT INTO t\_user(name，age) VALUES (#{name}，#{age})
</insert>
```

实际上我们并不是将整个对象持久化到数据库中，而是将对象中的属性持久化到数据库中，而这些属性（如 Date/String）都实现了 Serializable 接口。



## 实现序列化和反序列化为什么要实现 Serializable 接口

在 Java 中实现了 Serializable 接口后， JVM 在类加载的时候就会发现我们实现了这个接口，然后在初始化实例对象的时候就会在底层帮我们实现序列化和反序列化。

如果被写对象类型不是 String、数组、Enum，并且没有实现 Serializable 接口，那么在进行序列化的时候，将抛出 NotSerializableException。



## 实现 Serializable 接口之后，为什么还要显示指定 serialVersionUID 的值

如果不显示指定 serialVersionUID，JVM 在序列化时会根据属性自动生成一个 serialVersionUID，然后与属性一起序列化，再进行持久化或网络传输。在反序列化时，JVM 会再根据属性自动生成一个新版 serialVersionUID，然后将这个新版 serialVersionUID 与序列化时生成的旧版 serialVersionUID 进行比较，如果相同则反序列化成功，否则报错.

如果显示指定了 serialVersionUID，JVM 在序列化和反序列化时仍然都会生成一个 serialVersionUID，但值为我们显示指定的值，这样在反序列化时新旧版本的 serialVersionUID 就一致了.

如果我们的类写完后不再修改，那么不指定 serialVersionUID，不会有问题，但这在实际开发中是不可能的，我们的类会不断迭代，一旦类被修改了，那旧对象反序列化就会报错。 所以在实际开发中，我们都会显示指定一个 serialVersionUID



## transient 关键字的作用

Java 语言的关键字，变量修饰符，如果用 transient 声明一个实例变量，当对象存储时，它的值不需要维持。

也就是说被 transient 修饰的成员变量，在序列化的时候其值会被忽略，在被反序列化后， transient 变量的值被设为初始值， 如 int 型的是 0，对象型的是 null



## 什么是泛型

Java 泛型是 JDK 5 中引⼊的⼀个新特性， 允许在定义类和接口的时候使⽤类型参数。声明的类型参数在使⽤时⽤具体的类型来替换。

泛型最⼤的好处是可以提⾼代码的复⽤性。以 List 接口为例，我们可以将 String、 Integer 等类型放⼊ List 中， 如不⽤泛型， 存放 String 类型要写⼀个 List 接口， 存放 Integer 要写另外⼀个 List 接口， 泛型可以很好的解决这个问题



## 如何停止一个正在运行的线程

1、**使用线程的 stop 方法**。

使用 stop () 方法可以强制终止线程。不过 stop 是一个被废弃掉的方法，不推荐使用。

使用 Stop 方法，会一直向上传播 ThreadDeath 异常，从而使得目标线程解锁所有锁住的监视器，即释放掉所有的对象锁。使得之前被锁住的对象得不到同步的处理，因此可能会造成数据不一致的问题。

2、**使用 interrupt 方法中断线程**，该方法只是告诉线程要终止，但最终何时终止取决于计算机。调用 interrupt 方法仅仅是在当前线程中打了一个停止的标记，并不是真的停止线程。

接着调用 Thread.currentThread ().isInterrupted () 方法，可以用来判断当前线程是否被终止，通过这个判断我们可以做一些业务逻辑处理，通常如果 isInterrupted 返回 true 的话，会抛一个中断异常，然后通过 try-catch 捕获。

3、**设置标志位**

设置标志位，当标识位为某个值时，使线程正常退出。设置标志位是用到了共享变量的方式，为了保证共享变量在内存中的可见性，可以使用 volatile 修饰它，这样的话，变量取值始终会从主存中获取最新值。

但是这种 volatile 标记共享变量的方式，在线程发生阻塞时是无法完成响应的。比如调用 Thread.sleep () 方法之后，线程处于不可运行状态，即便是主线程修改了共享变量的值，该线程此时根本无法检查循环标志，所以也就无法实现线程中断。

因此，interrupt () 加上手动抛异常的方式是目前中断一个正在运行的线程**最为正确**的方式了



## 设计接口要注意什么

1. **接口参数校验**。接口必须校验参数，比如入参是否允许为空，入参长度是否符合预期。
2. 设计接口时，充分考虑接口的**可扩展性**。思考接口是否可以复用，怎样保持接口的可扩展性。
3. **串行调用考虑改并行调用**。比如设计一个商城首页接口，需要查商品信息、营销信息、用户信息等等。如果是串行一个一个查，那耗时就比较大了。这种场景是可以改为并行调用的，降低接口耗时。
4. 接口是否需要**防重**处理。涉及到数据库修改的，要考虑防重处理，可以使用数据库防重表，以唯一流水号作为唯一索引。
5. **日志打印全面**，入参出参，接口耗时，记录好日志，方便甩锅。
6. 修改旧接口时，注意**兼容性设计**。
7. **异常处理得当**。使用 finally 关闭流资源、使用 log 打印而不是 e.printStackTrace ()、不要吞异常等等
8. 是否需要考虑**限流**。限流为了保护系统，防止流量洪峰超过系统的承载能力



## *过滤器和拦截器有什么区别

**实现原理不同**。

过滤器和拦截器底层实现不同。过滤器是基于函数回调的，拦截器是基于 Java 的反射机制（动态代理）实现的。一般自定义的过滤器中都会实现一个 doFilter () 方法，这个方法有一个 FilterChain 参数，而实际上它是一个回调接口。

2、**使用范围不同**。

过滤器实现的是 javax.servlet.Filter 接口，而这个接口是在 Servlet 规范中定义的，也就是说过滤器 Filter 的使用要依赖于 Tomcat 等容器，导致它只能在 web 程序中使用。而拦截器是一个 Spring 组件，并由 Spring 容器管理，并不依赖 Tomcat 等容器，是可以单独使用的。拦截器不仅能应用在 web 程序中，也可以用于 Application、Swing 等程序中。

3、**使用的场景不同**。

因为拦截器更接近业务系统，所以拦截器主要用来实现项目中的业务判断的，比如：日志记录、权限判断等业务。而过滤器通常是用来实现通用功能过滤的，比如：敏感词过滤、响应数据压缩等功能。

4、**触发时机不同**。

过滤器 Filter 是在请求进入容器后，但在进入 servlet 之前进行预处理，请求结束是在 servlet 处理完以后。

拦截器 Interceptor 是在请求进入 servlet 后，在进入 Controller 之前进行预处理的，Controller 中渲染了对应的视图之后请求结束。

5、**拦截的请求范围不同**。

请求的执行顺序是：请求进入容器 -> 进入过滤器 -> 进入 Servlet -> 进入拦截器 -> 执行控制器。可以看到过滤器和拦截器的执行时机也是不同的，过滤器会先执行，然后才会执行拦截器，最后才会进入真正的要调用的方法。



## *让接口性能提升`通用的设计优化思想`

1. **池化思想**

   如果你每次需要用到线程，都去创建，就会有增加一定的耗时，而线程池可以重复利用线程，避免不必要的耗时。

   比如 `TCP` 三次握手，它为了减少性能损耗，引入了 `Keep-Alive长连接`，避免频繁的创建和销毁连接。

2. **拒绝阻塞等待**

   如果你调用一个系统 `B` 的接口，但是它处理业务逻辑，耗时需要 `10s` 甚至更多。然后你是一直**阻塞等待，直到系统 B 的下游接口返回**，再继续你的下一步操作吗？这样**显然不合理**。

   参考 **IO 多路复用模型**。即我们不用阻塞等待系统 `B` 的接口，而是先去做别的操作。等系统 `B` 的接口处理完，通过**事件回调**通知，我们接口收到通知再进行对应的业务操作即可。

3. **远程调用由串行改为并行**

   比如设计一个商城首页接口，需要查商品信息、营销信息、用户信息等等。如果是串行一个一个查，那耗时就比较大了。这种场景是可以改为并行调用的，降低接口耗时。

4. **锁粒度避免过粗**

   在高并发场景，为了防止**超卖等情况**，我们经常需要**加锁来保护共享资源**。但是，如果加锁的粒度过粗，是很影响接口性能的。

   不管你是 `synchronized` 加锁还是 `redis` 分布式锁，只需要在共享临界资源加锁即可，不涉及共享资源的，就不必要加锁。

5. **耗时操作，考虑放到异步执行**

   耗时操作，考虑用**异步处理**，这样可以降低接口耗时。比如用户注册成功后，短信邮件通知，是可以异步处理的。

6. **使用缓存**

   把要查的数据，提前放好到缓存里面，需要时，**直接查缓存，而避免去查数据库或者计算的过程**。

7. **提前初始化到缓存**

   预取思想很容易理解，就是**提前把要计算查询的数据，初始化到缓存**。如果你在未来某个时间需要用到某个经过复杂计算的数据，**才实时去计算的话，可能耗时比较大**。这时候，我们可以采取预取思想，**提前把将来可能需要的数据计算好，放到缓存中**，等需要的时候，去缓存取就行。这将大幅度提高接口性能。

8. **压缩传输内容**

   压缩传输内容，传输报文变得更小，因此传输会更快。

9. 数据尽量一次性传输完成，减少IO



## `Object` 类的与线程相关方法

1. `wait()`

   - **概述**：使当前线程等待，直到其他线程调用此对象的 `notify()` 或 `notifyAll()` 方法

   - **说明**：调用 `wait()` 方法的线程会释放它所持有的对象的监视器锁（monitor lock），进入等待状态，直到其他线程调用 `notify()` 或 `notifyAll()` 唤醒它

2. `notify()`
   - **概述**：唤醒正在等待此对象监视器的单个线程。如果有多个线程在等待，则其中一个线程会被唤醒，选择是任意的。

3. `notifyAll()`
   - **概述**：唤醒正在等待此对象监视器的所有线程。





##  面向对象有哪些特性？

面向对象四大特性：封装，继承，多态，

1、封装就是将类的信息隐藏在类内部，不允许外部程序直接访问，而是通过该类的方法实现对隐藏信息的操作和访问。 **良好的封装能够减少耦合**。

2、继承是从已有的类中派生出新的类，新的类继承父类的属性和行为，并能扩展新的能力，大大增加程序的重用性和易维护性。在 Java 中是单继承的，也就是说一个子类只有一个父类。

3、多态是同一个行为具有多个不同表现形式的能力。在不修改程序代码的情况下改变程序运行时绑定的代码。实现多态的三要素：继承、重写、父类引用指向子类对象。

- 静态多态性：通过**重载**实现，相同的方法有不同的參数列表，可以根据参数的不同，做出不同的处理。
- 动态多态性：在子类中重写父类的方法。运行期间判断所引用对象的实际类型，根据其实际类型调用相应的方法。



## **Java 创建对象有几种方式**

1. 使用 **new 关键字**：这是最常见的创建对象的方式。通过调用类的构造函数，使用 new 关键字可以在内存中分配一个新的对象。
2. 使用**反射**：Java 的反射机制允许在运行时动态地创建对象。通过获取类的 Class 对象，并调用其构造函数，可以实现对象的创建。
3. 使用 newInstance () 方法：某些类提供了 newInstance () 方法来创建对象，这种方式只适用于具有默认无参构造函数的类。
4. 使用 **clone ()** 方法：如果类实现了 Cloneable 接口，就可以使用 clone () 方法创建对象的副本。
5. 使用对象的**反序列化**：通过将对象序列化到一个字节流中，然后再进行反序列化，可以创建对象的副本。



## **equals 与 == 区别**(为什么要重写equals)

"==" 比较的是变量的值或引用的地址值，而 "equals ()" 比较的是对象的内容。

> 对于引用类型，使用 "equals ()" 进行比较更加准确和灵活，但需要注意重写 "equals ()" 方法，以满足自定义的比较需求。
>
> 如果调用Object的equals方法必须是原对象本身才会返回true，所以一定要重写equals

```java
//Object的equals 
public boolean equals(Object obj) {
        return (this == obj);
    }
```



## **final，finally，finalize 的区别**

- final 是修饰符，用于限定类、方法和变量的性质。

  - 用于修饰类时，表示该类不能被继承，即为最终类。

  - 用于修饰方法时，表示该方法不能被子类重写。

  - 用于修饰变量时，表示该变量是一个常量，其值不能被修改。

-  finally 是一个关键字，用于定义一个代码块，在异常处理中用于确保特定代码无论如何都会被执行。

- finalize 是一个 Object 类中的方法，用于对象的垃圾回收前的清理操作。



## **重载和重写的区别**

在 Java 中，重载和重写是两个不同的概念，它们都用于实现多态性，但是具体的实现方式和作用不同。

1. 重载：

   - 重载是指在同一个类中，可以有多个方法名相同但**参数类型、参数个数或参数顺序**不同的方法。

     > 重载的作用是增加方法的灵活性和可读性，让同一个方法名可以对不同情况进行处理。

2. 重写：

   - 重写是指在子类中可以对父类的方法进行重写。

   - 重写方法必须与被重写方法拥有相同的方法名、返回值类型和参数列表，但是可以更改访问修饰符、抛出的异常类型和方法体等。

     > 通过父类引用调用子类对象的方法，实现对同一方法名的不同实现。

   区别：

   - 重载是指在同一个类中对相同方法名的多次定义，而重写是指在继承关系中对父类方法的重新定义。
   - 重载的**方法签名**（方法名、参数类型、个数和顺序）必须**不同**，而重写的**方法签名必须相同**。
   - 重载的目的是提供**更加灵活的方法调用方式**，重写的目的是**实现多态性**。



## ***抽象类和接口有什么区别**

1. 抽象类是使用 abstract 关键字定义的类，可以包含抽象方法和非抽象方法，可以有实例变量和构造方法

   接口通过 interface 关键字定义，只能包含抽象方法、默认方法和静态方法，不包含实例变量或构造方法。

2. 一个类只能继承自一个抽象类，但可以实现多个接口
3. 抽象类可以包含**非抽象方法**，子类可以直接使用；接口可以包含**默认方法**，提供通用实现

抽象类的设计目的是提供类的继承机制，实现代码复用，适用于拥有相似行为和属性的类

接口的设计目的是定义一组规范或契约，实现类遵循特定的行为和功能，适用于不同类之间的解耦和多态性实现。



## **String，Stringbuffer，StringBuilder 的区别**

1. 可变性：
   - String 是不可变的类，一旦创建就不能被修改。每次对 String 进行操作时，都会创建一个新的 String 对象。
   - StringBuffer 和 StringBuilder 是可变的类，可以动态修改字符串内容。
2. 线程安全性：
   - String 是线程安全的，因为它是不可变的。多个线程可以同时访问同一个 String 对象而无需担心数据的修改问题。
   - StringBuffer 是线程安全的，它的方法使用了 synchronized 关键字进行同步，保证在多线程环境下的安全性。
   - StringBuilder 是非线程安全的，不使用 synchronized 关键字，所以在多线程环境下使用时需要手动进行同步控制。
3. 性能：
   - 由于 String 是不可变的，每次对 String 进行操作都会创建一个新的 String 对象，频繁的字符串拼接会导致大量的对象创建和内存消耗。
   - StringBuffer 是可变的，对字符串的修改是在原有对象上进行，不会创建新的对象，因此在频繁的字符串拼接场景下比 String 更高效。
   - StringBuilder 与 StringBuffer 类似，但不保证线程安全性，因此在单线程环境下性能更高。



## **反射用途及实现原理**

- 反射是 Java 语言中的一项特性，它允许程序在运行时**动态地获取和操作类的信息**。通过反射，我们可以在编译时未知的情况下，获取类的**构造函数、方法、字段，并在运行时动态地创建对象、调用方法以及访问和修改字段的值**。

- 反射的应用有很多方面。首先，它提供了一种**动态加载类**的机制，使得我们可以在运行时根据需要加载外部的类和资源，实现插件化的架构。

- 其次，反射能够实现**对象的动态创建和初始化**。通过获取类的构造函数，并调用 newInstance () 方法，我们可以在运行时动态地创建对象，而不需要提前知道具体的类名。

- 另外，通过反射可以**动态地调用类的方法**。我们可以获取类的方法对象，并使用 **invoke ()** 方法来调用这些方法，甚至可以调用私有方法。

- 反射还允许我们**获取类的字段信息**，并在运行时对其进行读取和修改。通过获取字段对象并使用get()和set()方法，我们可以访问和修改类的字段，包括私有字段。

- 此外，反射还提供了检查类的注解、泛型信息以及父类和接口的能力，为框架开发和工具编写提供了便利。

  尽管反射提供了很大的灵活性，但也需要注意它的使用场景和性能影响。反射操作通常比直接调用方法和访问字段的**性能要低**，因此在对性能要求较高的场景中应谨慎使用。



## **什么是守护线程？与普通线程的区别**

守护线程是在程序运行时在后台提供一种支持性的线程。与普通线程相比，守护线程有以下几个区别：

1. 终止条件：当所有用户线程结束时，守护线程会自动停止。换句话说，**守护线程不会阻止程序的终止，即使它们还没有执行完任务**。
2. 生命周期：守护线程的生命周期与主线程或其他用户线程无关。**当所有的非守护线程都结束时，JVM 将会退出并停止守护线程的执行**。
3. 线程优先级：守护线程的优先级默认与普通线程一样。优先级较高的守护线程也不能够保证在其他线程之前执行。
4. 资源回收：守护线程通常被用于执行一些后台任务，例如**垃圾回收、日志记录、定时任务**等。当只剩下守护线程时，JVM 会自动退出并且不会等待守护线程执行完毕。

​	需要注意的是，守护线程与普通线程在编写代码时没有太大的区别。可以通过将线程的setDaemon(true)方法设置为 true，将普通线程转换为守护线程。
​	总结起来，守护线程在程序运行过程中提供了一种支持性的服务，会在所有的用户线程结束时自动停止。



