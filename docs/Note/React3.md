---
group: React
title: React合成事件机制
order: 3
---

## React 合成事件机制

### 前言

Javascript 中的事件传播机制有三个阶段：捕获阶段、目标阶段、冒泡阶段。之所以设置捕获阶段和冒泡阶段是为了让开发者可以在不同层级的元素上处理事件。

- 捕获阶段：当某个元素触发某个事件（如 onclick ），顶层对象 document 就会发出一个事件流，随着 DOM 树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。
- 目标阶段：执行阶段。
- 冒泡阶段：从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被触发一次。如果想阻止事件冒泡，可以使用 e.stopPropagation() 或者 e.cancelBubble=true（IE）来阻止事件的冒泡传播。

### 事件委托

将响应事件绑定到另一个元素（父元素、祖先元素）。
当子节点被点击时，click 事件向上冒泡，父节点捕获到事件后，我们判断是否为所需的节点，然后进行处理

### React 实现合成事件机制的好处

- 将事件绑定到根节点，减少了事件监听器的简历，节省内存
- 磨平不同浏览器差异。
- 对开发者友好。

### 实现细节

React 对原生事件和合成事件进行了分类对应，例如`onChange`合成事件，它依赖了`['change','click','focusin','focusout','input','keydown','keyup','selectionchange']`原生事件。再根据原生事件是否具有**冒泡阶段**，分为**可代理事件**和**非代理事件**。

- 可代理事件，会在根节点上绑定捕获阶段和冒泡阶段的监听器。
- 非代理事件，在根节点只绑定捕获阶段的监听器(因为不存在冒泡阶段，就算在根节点绑定冒泡阶段的监听器也不会被触发)，在目标元素上添加响应的冒泡阶段监听器。实际上，对于非代理事件，react 都进行了冒泡模拟。

那么原生事件和合成事件之间的区别在哪？
React 的合成事件是基于事件委托的，由此可见是在冒泡阶段执行相应事件。而原生事件是在目标阶段，先于合成事件。（俩者不要一起用）。同时对于合成事件的阻止冒泡，只要使用 e.stopPropagation()，不用考虑浏览器之间的差异。

### 事件代理阶段

在 React16 中，对 document 的事件委托是在冒泡阶段，当事件冒泡到 document 后触发绑定的回调函数，回调函数会重新执行一遍**捕获-冒泡**，所以 React 事件中的 e.stopPropagation()无法阻止原生事件的捕获和冒泡，因为已经执行完了。

在 React17 中，对根容器的事件委托分别在捕获阶段和冒泡阶段：

- 根容器接收到捕获事件后，先执行 React 事件的捕获阶段，然后再执行原生事件的捕获阶段，所以 React 的 e.stopPropagation()可以阻止原生事件的捕获阶段。
- 根容器接收到冒泡事件后，会触发一次 React 事件的冒泡阶段，此时原生事件的冒泡传播已经传播到根了，所以 React 事件的冒泡阶段调用 e.stopPropagation()不能阻止原生事件向根容器的传播，但是能阻止根容器到页面顶层的传播。
