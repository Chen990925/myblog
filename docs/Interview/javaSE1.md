---
group: java基础
title: java基础面试题1
order: 1
---

# Java基础 面试题

##  面向对象有哪些特性？

面向对象四大特性：封装，继承，多态，

1、封装就是将类的信息隐藏在类内部，不允许外部程序直接访问，而是通过该类的方法实现对隐藏信息的操作和访问。 **良好的封装能够减少耦合**。

2、继承是从已有的类中派生出新的类，新的类继承父类的属性和行为，并能扩展新的能力，大大增加程序的重用性和易维护性。在 Java 中是单继承的，也就是说一个子类只有一个父类。

3、多态是同一个行为具有多个不同表现形式的能力。在不修改程序代码的情况下改变程序运行时绑定的代码。实现多态的三要素：继承、重写、父类引用指向子类对象。

- 静态多态性：通过**重载**实现，相同的方法有不同的參数列表，可以根据参数的不同，做出不同的处理。
- 动态多态性：在子类中重写父类的方法。运行期间判断所引用对象的实际类型，根据其实际类型调用相应的方法。



## **Java 创建对象有几种方式**

1. 使用 **new 关键字**：这是最常见的创建对象的方式。通过调用类的构造函数，使用 new 关键字可以在内存中分配一个新的对象。
2. 使用**反射**：Java 的反射机制允许在运行时动态地创建对象。通过获取类的 Class 对象，并调用其构造函数，可以实现对象的创建。
3. 使用 newInstance () 方法：某些类提供了 newInstance () 方法来创建对象，这种方式只适用于具有默认无参构造函数的类。
4. 使用 **clone ()** 方法：如果类实现了 Cloneable 接口，就可以使用 clone () 方法创建对象的副本。
5. 使用对象的**反序列化**：通过将对象序列化到一个字节流中，然后再进行反序列化，可以创建对象的副本。



## **equals 与 == 区别**(为什么要重写equals)

"==" 比较的是变量的值或引用的地址值，而 "equals ()" 比较的是对象的内容。

> 对于引用类型，使用 "equals ()" 进行比较更加准确和灵活，但需要注意重写 "equals ()" 方法，以满足自定义的比较需求。
>
> 如果调用Object的equals方法必须是原对象本身才会返回true，所以一定要重写equals

```java
//Object的equals 
public boolean equals(Object obj) {
        return (this == obj);
    }
```



## **final，finally，finalize 的区别**

- final 是修饰符，用于限定类、方法和变量的性质。

  - 用于修饰类时，表示该类不能被继承，即为最终类。

  - 用于修饰方法时，表示该方法不能被子类重写。

  - 用于修饰变量时，表示该变量是一个常量，其值不能被修改。

-  finally 是一个关键字，用于定义一个代码块，在异常处理中用于确保特定代码无论如何都会被执行。

- finalize 是一个 Object 类中的方法，用于对象的垃圾回收前的清理操作。



## **重载和重写的区别**

在 Java 中，重载和重写是两个不同的概念，它们都用于实现多态性，但是具体的实现方式和作用不同。

1. 重载：

   - 重载是指在同一个类中，可以有多个方法名相同但**参数类型、参数个数或参数顺序**不同的方法。

     > 重载的作用是增加方法的灵活性和可读性，让同一个方法名可以对不同情况进行处理。

2. 重写：

   - 重写是指在子类中可以对父类的方法进行重写。

   - 重写方法必须与被重写方法拥有相同的方法名、返回值类型和参数列表，但是可以更改访问修饰符、抛出的异常类型和方法体等。

     > 通过父类引用调用子类对象的方法，实现对同一方法名的不同实现。

   区别：

   - 重载是指在同一个类中对相同方法名的多次定义，而重写是指在继承关系中对父类方法的重新定义。
   - 重载的**方法签名**（方法名、参数类型、个数和顺序）必须**不同**，而重写的**方法签名必须相同**。
   - 重载的目的是提供**更加灵活的方法调用方式**，重写的目的是**实现多态性**。



## ***抽象类和接口有什么区别**

1. 抽象类是使用 abstract 关键字定义的类，可以包含抽象方法和非抽象方法，可以有实例变量和构造方法

   接口通过 interface 关键字定义，只能包含抽象方法、默认方法和静态方法，不包含实例变量或构造方法。

2. 一个类只能继承自一个抽象类，但可以实现多个接口
3. 抽象类可以包含**非抽象方法**，子类可以直接使用；接口可以包含**默认方法**，提供通用实现

抽象类的设计目的是提供类的继承机制，实现代码复用，适用于拥有相似行为和属性的类

接口的设计目的是定义一组规范或契约，实现类遵循特定的行为和功能，适用于不同类之间的解耦和多态性实现。



## **String，Stringbuffer，StringBuilder 的区别**

1. 可变性：
   - String 是不可变的类，一旦创建就不能被修改。每次对 String 进行操作时，都会创建一个新的 String 对象。
   - StringBuffer 和 StringBuilder 是可变的类，可以动态修改字符串内容。
2. 线程安全性：
   - String 是线程安全的，因为它是不可变的。多个线程可以同时访问同一个 String 对象而无需担心数据的修改问题。
   - StringBuffer 是线程安全的，它的方法使用了 synchronized 关键字进行同步，保证在多线程环境下的安全性。
   - StringBuilder 是非线程安全的，不使用 synchronized 关键字，所以在多线程环境下使用时需要手动进行同步控制。
3. 性能：
   - 由于 String 是不可变的，每次对 String 进行操作都会创建一个新的 String 对象，频繁的字符串拼接会导致大量的对象创建和内存消耗。
   - StringBuffer 是可变的，对字符串的修改是在原有对象上进行，不会创建新的对象，因此在频繁的字符串拼接场景下比 String 更高效。
   - StringBuilder 与 StringBuffer 类似，但不保证线程安全性，因此在单线程环境下性能更高。



## **反射用途及实现原理**

- 反射是 Java 语言中的一项特性，它允许程序在运行时**动态地获取和操作类的信息**。通过反射，我们可以在编译时未知的情况下，获取类的**构造函数、方法、字段，并在运行时动态地创建对象、调用方法以及访问和修改字段的值**。

- 反射的应用有很多方面。首先，它提供了一种**动态加载类**的机制，使得我们可以在运行时根据需要加载外部的类和资源，实现插件化的架构。

- 其次，反射能够实现**对象的动态创建和初始化**。通过获取类的构造函数，并调用 newInstance () 方法，我们可以在运行时动态地创建对象，而不需要提前知道具体的类名。

- 另外，通过反射可以**动态地调用类的方法**。我们可以获取类的方法对象，并使用 **invoke ()** 方法来调用这些方法，甚至可以调用私有方法。

- 反射还允许我们**获取类的字段信息**，并在运行时对其进行读取和修改。通过获取字段对象并使用get()和set()方法，我们可以访问和修改类的字段，包括私有字段。

- 此外，反射还提供了检查类的注解、泛型信息以及父类和接口的能力，为框架开发和工具编写提供了便利。

  尽管反射提供了很大的灵活性，但也需要注意它的使用场景和性能影响。反射操作通常比直接调用方法和访问字段的**性能要低**，因此在对性能要求较高的场景中应谨慎使用。



## **什么是守护线程？与普通线程的区别**

守护线程是在程序运行时在后台提供一种支持性的线程。与普通线程相比，守护线程有以下几个区别：

1. 终止条件：当所有用户线程结束时，守护线程会自动停止。换句话说，**守护线程不会阻止程序的终止，即使它们还没有执行完任务**。
2. 生命周期：守护线程的生命周期与主线程或其他用户线程无关。**当所有的非守护线程都结束时，JVM 将会退出并停止守护线程的执行**。
3. 线程优先级：守护线程的优先级默认与普通线程一样。优先级较高的守护线程也不能够保证在其他线程之前执行。
4. 资源回收：守护线程通常被用于执行一些后台任务，例如**垃圾回收、日志记录、定时任务**等。当只剩下守护线程时，JVM 会自动退出并且不会等待守护线程执行完毕。

​	需要注意的是，守护线程与普通线程在编写代码时没有太大的区别。可以通过将线程的setDaemon(true)方法设置为 true，将普通线程转换为守护线程。
​	总结起来，守护线程在程序运行过程中提供了一种支持性的服务，会在所有的用户线程结束时自动停止。



