---
group: JavaScript
title: JavaScript
order: 1
---

## 赋值、浅拷贝、深拷贝

> 浅拷贝、深拷贝都只是针对引用数据类型的（Object 和 Array）

- 赋值：对于基本数据结构，赋值是拷贝值，开辟新的内存地址存值；对于引用数据类型，赋值是拷贝了一份引用，指向同一块内存地址。
- 浅拷贝：浅拷贝是**按位拷贝对象**，它会创建一个新对象，对于基本数据类型拷贝的是值；对于引用数据类型拷贝的是引用，也就是说属性值为引用数据类型的，新旧对象属性指向同一块内存地址。(可以理解为浅拷贝只拷贝了一层对象)
- 深拷贝：深拷贝会另外创造一个一模一样的对象，新对象跟原对象**不共享内存**，修改新对象不会改到原对象。

浅拷贝的实现方法：

- Object.assign()
- Array.prototype.concat()
- Array.prototype.slice()
- 解构赋值 **...**

深拷贝的实现方法：

- JSON.parse(JSON.stringify())
- 函数库 lodash

## 事件循环:微任务和宏任务

浏览器中的 JavaScript 和 NodeJs 中的流程都是基于事件循环的

事件循环是 JavaScript 引擎在等待任务、执行任务俩个状态中不断循环的过程。

其中任务就分为两类：**宏任务与微任务**。

### 何为宏任务？

- 渲染事件(DOM 渲染、重绘、计算布局)
- 用户交互事件(鼠标、键盘等事件)
- 网络请求
- JavaScript 脚本事件

为了比较好的控制任务，页面进程引入了消息队列和事件循环机制，将要执行的宏任务依次添加到队列中，秉承着**先进先出**的良好品德，就这样有条不紊的按顺序执行，执行完毕就拍拍屁股滚出队列。

但是对于**精确时间的把控**，宏任务就难以胜任了。

DOM 事件、用户交互事件、网络请求等任务都是系统添加进队列的，我们不知道他们在队列中的次序是如何的，所以对于任务什么时候开始，我们无法掌握。

例如：

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="content">
      <li>xx</li>
    </div>
  </body>
  <script type="text/javascript">
    function timerCallback2() {
      console.log(2);
    }
    function timerCallback() {
      console.log(1);
      setTimeout(timerCallback2, 0);
    }
    setTimeout(timerCallback, 0);
  </script>
</html>
```

示例中，JavaScript 脚本任务有俩个定时器。我们所希望实现的效果是，俩个定时器执行的时机是无缝衔接的，但是 setTimeout 的执行间隔虽然可以设置成 0，实际上却是有 4ms 的间隔，所以很有可能在这间隔中就会被系统添加一些任务进入队列，打乱了队列。

宏任务的时间粒度大，使它难以胜任一些高实时性的需求。

这时候，微任务就应运而生了。

### 何为微任务？

微任务的执行时机是主函数执行结束之后，当前宏函数执行结束之前。这么说大家脑海里首先浮现的是不是 Promise 的处理程序.then/.catch。

是的，它们就是典型的微任务。

宏任务有它的消息队列，微任务也有它的消息队列。当宏任务中的 JavaScript 快执行完的时候，JavaScript 引擎会查看当前微任务队列中是否有任务，如果有的话就按照顺序依次执行。
