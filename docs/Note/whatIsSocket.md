---
group: netty
title: 到底什么是socket?
order: 1
---

# 到底什么是socket？

socket:翻译插座，所以得从插座说起。

在我们网络编程时，正是通过类似于插座的方式建立连接，那具体建立连接的流程是怎么样呢？

1. 两端各自执行socket()方法，得到**fd**句柄。`fd:文件描述符，用于标志一个打开的文件或IO设备，用于文件的索引`

2. 服务端依次执行bind,listen,accept方法等待客户端连接请求。

3. 客户端执行connect后建立连接。

4. 连接建立后，两端都可以通过send和recv方法接发请求。

---

但此时，我们对socket还是一无所知，那就重新设计一个**内核网络传输功能**吧：

网络传输的操作无非就是读数据和写数据，为了实现网络**读写**，我们新设计一个数据结构名为**sock**。

接下来看看有哪些传输方式：

- 可靠的TCP协议
- 不可靠的UDP协议
- ICMP协议的ping .....

 按面向对象编程的思想，我们可以将不同协议当成不同对象，将公共部分抽取，使用继承的方式复用功能。

然后！

1. **sock**就成为了这些对象的公共部分，维护**任何协议**都会用到的**缓冲区和消息列表**。

2. 因为接收端和发送端大概率不止一个，所以我们往这个数据结构里加入属性：**IP**`标记哪台电脑`，**端口**`定位进程`，ttl`生存时间`成为**inet_sock**

[ttl](https://baike.baidu.com/item/TTL/130248?fr=ge_ala "ttl解释")

3. 在**inet_sock**加入面向连接的协议相关字段，譬如accept队列，数据包大小，握手失败重试次数等，成为**inet_connnection_sock**（有些协议不是面向连接的）
4. 在**inet_connnection_sock**上加入tcp特有的滑动窗口，拥塞避免等功能就成为了**tcp_sock**，也就是tcp所使用的sock

 现在，我们就有了这套用于网络传输的数据结构sock，将其与硬件网卡对接一下，大功告成!

`当然sock里面的代码逻辑是很复杂的，既要操作连接还要操作硬件，我们就将其放到操作系统内核里`

**因为操作文件和操作网络一样都可以抽象为读和写，而linux里一切皆文件，那我们就将内核的sock结构封装成文件好啦**。这样在我们**创建sock时就会创建一个对应文件**`文件和sock不是一回事`，而文件就会有fd句柄，之后我们通过操作句柄，系统就会将指令指向内核sock结构`怎么关联的呢？`[跳转](#发送)

为了方便，我们再将fd句柄的操作抽象为一个个api(send,bind,recv,listen等)供别人调用，也就是开发中socket提供的接口

 **至此，我们的网络传输功能设计完成！**

---

socket其实就是个**代码库或接口层**，介于内核和程序之间，提供了高度封装的接口给我们调用，让我们去实现网络传输。

**所以说代码里写的socket将网络传输的工作扔给了linux内核来外包实现的**

现在我们来看socket中文翻译：套接字（一套用于连接的数字）

# 以TCP协议为例看socket如何实现网络传输

## 一阶段：建立连接

1. 在客户端，代码执行socket提供的connect方法传入fd和ip,端口
2. 内核通过fd找到对应文件，根据文件信息找到内核里的sock结构
3. 通过sock结构发起三次握手，至此连接完成

## 二阶段：数据传输

### 发送

1. 应用执行send发送数据，同样也会根据fd找到sock
2. 将数据放到发送缓冲区，结束流程，内核看心情决定何时发送这份数据

### 接收（类似）

1. 当数据进入内核后不是马上给程序的，而是先放到接收缓冲区中
2. 数据卑微等待应用程序执行recv方法接收数据

**那么问题又来了，很多数据包发送到listen socket上，怎么区分这么多客户端呢？**

1. 数据包上会有源IP和端口和目的地址ip和端口，服务端依靠这四个元素可以唯一标记一个客户端。
2. 服务端会根据四元组创建一个新sock并生存hashkey放入到一个hash表（包含所有客户端的sock,hashkey->专属 scok）
3. 之后进来的消息通过消息的hashkey直接找到专属的sock来操作

**也就是说，服务端是通过消息的四元组来区分多个客户端的**