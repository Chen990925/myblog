---
group: springCloud
title: 微服务介绍
order: 1
---

# 微服务介绍

## 单体架构 vs 微服务架构

### 什么是单体架构

一个归档包（例如 war 格式）包含了应用所有功能的应用程序，我们通常称之为单体应用。架构单体应用的方法论，我们称之为单体应用架构。（就是一个 war 包打天下）

**单体架构的优缺点**：

**优点**:

1. 架构简单明了，没有” 花里胡哨 “的问题需要解决。
2. 开发，测试，部署简单（尤其是运维人员 ）

**缺点**:

1. 随着业务扩展，代码越来越复杂，代码质量参差不齐 (开发人员的水平不一), 会让你每次提交代码 ，修改每一个小 bug 都是心惊胆战的。
2. 部署慢 (由于单体架构，功能复杂) 能想像下一个来自 200W + 代码部署的速度 (15 分钟)
3. 扩展成本高，根据单体架构图 假设用户模块是一个 CPU 密集型的模块 (涉及到大量的运算)，那么我们需要替换更加牛逼的 CPU，而我们的订单模块是一个 IO 密集模块（涉及大量的读写磁盘）, 那我们需要替换更加牛逼的内存以及高效的磁盘。但是我们的单体架构上 无法针对单个功能模块进行扩展，那么就需要替换更牛逼的 CPU，更牛逼的内存，更牛逼的磁盘，价格蹭蹭的往上涨。
4. 阻碍了新技术的发展。。。。。。比如我们的 web 架构模块 从 struts2 迁移到 springboot，那么就会成为灾难



## 微服务以及微服务架构

微服务核心就是把传统的单机应用，根据业务将单机应用拆分为一个一个的服务，彻底的解耦

**每一个服务都是提供特定的功能，一个服务只做一件事，类似进程，每个服务都能够单独部署，甚至可以拥有自己的数据库。**这样的一个一个的小服务就是微服务。

1. 比如传统的单机电商应用，有订单 / 支付 / 库存 / 物流 / 积分等模块 (理解为 service)
2. 我们根据业务模型来拆分，可以拆分为 订单服务，支付服务，库存服务，物流服务，积分服务
3. 若不拆分的时候，我的非核心业务积分模块 出现了重大 bug 导致系统内存溢出，导致整个服务宕机 , 若拆分之后，只是说我的积分微服务不可用，我的整个系统核心功能还是能使用



### 微服务的特点

- **独立部署，灵活扩展**

  传统的单体架构是以整个系统为单位进行部署，而微服务则是**以每一个独立组件（例如用户服务，商品服务）为单位进行部署**。

- **资源的有效隔离**

  微服务设计的原则之一，就是每一个微服务拥有独立的数据源，假如微服务 A 想要读写微服务 B 的数据库，只能调用微服务 B 对外暴露的接口来完成。**这样有效避免了服务之间争用数据库和缓存资源所带来的问题**

- **团队组织架构的调整**

  微服务设计的思想也改变了原有的企业研发团队组织架构。传统的研发组织架构是水平架构，前端有前端的团队，后端有后端的团队，DBA 有 DBA 的团队，测试有测试的团队。而微服务的设计思想对团队的划分有着一定的影响，**使得团队组织架构的划分更倾向于垂直架构，比如用户业务是一个团队来负责，支付业务是一个团队来负责**。



### **微服务架构是什么**

微服务架构风格是一种将单个应用程序作为一套小型服务开发的方法，每种应用程序都在自己的进程中运行，并与轻量级机制（通常是 HTTP 资源 API）进行通信。 这些服务是围绕业务功能构建的，可以通过全自动部署机制独立部署。 

这些服务的集中管理最少，可以用不同的编程语言编写，并使用不同的数据存储技术

**SOA 架构强调的是异构系统之间的通信和解耦合，而微服务架构强调的是系统按业务边界做细粒度的拆分和部署**

微服务架构是一个架构风格，提倡: 

- 将一个单一应用程序开发为一组小型服务
- 每个服务运行在自己的进程中
- 服务之间通过轻量级的通信机制 (http rest api)
- 每个服务都能够独立的部署
- 每个服务甚至可以拥有自己的数据库

**微服务以及微服务架构的是二个完全不同的概念。微服务强调的是服务的大小和对外提供的单一功能，而微服务架构是指把 一个一个的微服务组合管理起来，对外提供一套完整的服务。**



### 微服务的优缺点

**优点**:

1. **每个服务足够小，足够内聚，代码更加容易理解**，专注一个业务功能点 (对比传统应用，可能改几行代码 需要了解整个系统)
2. **开发简单**，一个服务只干一个事情。（加入你做支付服务，你只要了解支付相关代码就可以了）
3. 微服务能够被 2-5 个人的小团队开发，**提高效率**
4. 按需伸缩，**服务松耦合**，每个服务都能够开发部署
5. **前后端分离**，作为 java 开发人员，我们只要关系后端接口的安全性以及性能，不要去关注页面的人机交互 (H5 工程师) 根据前后端接口协议，根据入参，返回 json 的回参。
6. 一个服务可用拥有自己的数据库，也可以多个服务连接同一个数据库。

**缺点**:

1. **增加了运维人员的工作量**，以前只要部署一个 war 包，现在可能需要部署成百上千个 war 包 (k8s+docker+jenkins)
2. 服务之间相互调用，**增加通信成本**
3. **数据一致性问题 (分布式事务问题)**
4. **性能监控等，问题定位.**...

### **微服务的适用场景**

**合适**

①: 大型复杂的项目............(来自单体架构 200W 行代码的恐惧)

②: 快速迭代的项目............(来自一天一版的恐惧)

③: 并发高的项目................(考虑弹性伸缩扩容的恐惧)

**不合适**

①：业务稳定，就是修修 bug ，改改数据

②：迭代周期长 发版频率 一二个月一次.



# Spring Cloud 微服务技术栈

**Spring Cloud 是分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶。** 

Spring Cloud 为开发人员**提供了快速构建分布式系统中的一些常见模式的工具**

 (例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、领导选举、分布式会话、集群状态)。



## **Spring Cloud Netflix 包含的组件：**

- **Eureka**：服务注册和发现，它提供了一个服务注册中心、服务发现的客户端，还有一个方便的查看所有注册的服务的界面。 所有的服务使用 Eureka 的服务发现客户端来将自己注册到 Eureka 的服务器上。

- **Zuul**，网关，所有的客户端请求通过这个网关访问后台的服务。他可以使用一定的路由配置来判断某一个 URL 由哪个服务来处理。并从 Eureka 获取注册的服务来转发请求。

- **Ribbon**，即负载均衡，Zuul 网关将一个请求发送给某一个服务的应用的时候，如果一个服务启动了多个实例，就会通过 Ribbon 来通过一定的负载均衡策略来发送给某一个服务实例。

- **Feign**，服务客户端，服务之间如果需要相互访问，可以使用 RestTemplate，也可以使用 Feign 客户端访问。它默认会使用 Ribbon 来实现负载均衡。

- **Hystrix**，监控和断路器。我们只需要在服务接口上添加 Hystrix 标签，就可以实现对这个接口的监控和断路器功能。

- Hystrix Dashboard，监控面板，他提供了一个界面，可以监控各个服务上的服务调用所消耗的时间等。

- Turbine，监控聚合，使用 Hystrix 监控，我们需要打开每一个服务实例的监控信息来查看。而 Turbine 可以帮助我们把所有的服务实例的监控信息聚合到一个地方统一查看。这样就不需要挨个打开一个个的页面一个个查看



## **Spring Cloud Alibaba 包含组件**

**阿里开源组件**

**Nacos**：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。

**Sentinel**：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。

**RocketMQ**：开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。

**Dubbo**：在国内应用非常广泛的一款高性能 Java RPC 框架。

**Seata**：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。

**Arthas**：开源的 Java 动态追踪工具，基于字节码增强技术，功能非常强大。



